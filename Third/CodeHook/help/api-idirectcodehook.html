<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="author" content="ATopSoft" />
<meta name="copyright" content="Copyright &copy; 2004-2007, ATopSoft, All Rights Reserved." />
<meta name="rating" content="Safe For Kids" />
<meta name="keywords" lang="en" content="meta key" />
<meta name="description" content="meta desc" />

<title>Win32 CodeHook</title>
<style type="text/css">@import url('page.css');</style>
<link rel="stylesheet" type="text/css" href="page.css" />
</head>


<body>
<div class="header">
</div>
<div class="container">
	<div class="mainbox">
		 <div class="nav"><ul>
<li><a href="index.html">Introduction</a></li>
<li><a href="start.html">Get start</a></li>
<li><a href="api-icodehook.html">Interface - ICodeHook</a></li>
<li><a href="api-icodehookhelper.html">Interface - ICodeHookHelper</a></li>
<li><a href="api-idirectcodehook.html">Interface - IDirectCodeHook</a></li>
<li><a href="api-ierrorcodehook.html">Interface - IErrorCodeHook</a></li>
<li><a href="compare-raw-advanced-mode.html">Comparison of raw mode and advanced mode</a></li>
<li><a href="tutorial.html">Tutorials</a></li>
<li><a href="faq.html">FAQ</a></li>
<li><a href="support.html">Support</a></li>
<li><a href="version.html">Credits and Versions</a></li>

</ul>

		 </div>
		 <div class="content">Document of interface IDirectCodeHook<br /><br />This interface is for raw mode hooking.<br />
You usually should use ICodeHook's raw mode hooking feature instead of use this interface directly.<br />
To get the interface, call ICodeHook.GetDirectCodeHook;<br /><br />Delphi syntax: <br /><pre>IDirectCodeHook = interface(IErrorCodeHook)
	function <a href="#Hook">Hook</a>(ATarget, AHook: Pointer; APreviousMethod: Pointer): LongBool; stdcall;
	function <a href="#Unhook">Unhook</a>(ATarget: Pointer; APreviousMethod: Pointer): LongBool; stdcall;
	function <a href="#AllocatePreviousMethodMemory">AllocatePreviousMethodMemory</a>: Pointer; stdcall;
	procedure <a href="#FreePreviousMethodMemory">FreePreviousMethodMemory</a>(APreviousMethod: Pointer); stdcall;
end;
</pre>C++ syntax: <br /><pre>class IDirectCodeHook: public ICodeHookError {
public:
	virtual BOOL _stdcall <a href="#Hook">Hook</a>(Pointer Target, Pointer <a href="#Hook">Hook</a>, Pointer OldFunc) = 0;
	virtual BOOL _stdcall <a href="#Unhook">Unhook</a>(Pointer Target, Pointer AOldFunc) = 0;
	virtual void * _stdcall <a href="#AllocatePreviousMethodMemory">AllocatePreviousMethodMemory</a>() = 0;
	virtual void <a href="#FreePreviousMethodMemory">FreePreviousMethodMemory</a>(Pointer OldFunc) = 0;
};
</pre><a id="Hook"></a><div class="function">Function: <h3>Hook</h3><br />Low level hook a method.<br />Delphi syntax: <br /><pre>function Hook(ATarget, AHook: Pointer; APreviousMethod: Pointer): LongBool; stdcall;</pre><br />C++ syntax: <br /><pre>virtual BOOL calltype Hook(Pointer Target, Pointer Hook, Pointer OldFunc) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ATarget</dt><dd>Address of the target function.</dd><dt class="ParamName">AHook</dt><dd>Address of the hook function.</dd><dt class="ParamName">APreviousMethod</dt><dd>Pointer to a memory block to store the previous method information. You may use IDirectCodeHook.AllocatePreviousMethodMemory to allocate memory.</dd></dl><b>Return value</b><dl><dt>Return TRUE on success, otherwise, return FALSE.</dt></dl><b>Remarks</b><dl><dt>Don't use this function, instead, use ICodeHook.Hook.</dt></dl></div>

<a id="Unhook"></a><div class="function">Function: <h3>Unhook</h3><br />Low level unhook a method.<br />Delphi syntax: <br /><pre>function Unhook(ATarget: Pointer; APreviousMethod: Pointer): LongBool; stdcall;</pre><br />C++ syntax: <br /><pre>virtual BOOL calltype Unhook(Pointer Target, Pointer AOldFunc) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ATarget</dt><dd>Address of the target function.</dd><dt class="ParamName">APreviousMethod</dt><dd>Address of the previous function.</dd></dl><b>Return value</b><dl><dt>Return TRUE on success, otherwise, return FALSE.</dt></dl><b>Remarks</b><dl><dt>Don't use this function, instead, use ICodeHook.Unhook.</dt></dl></div>

<a id="AllocatePreviousMethodMemory"></a><div class="function">Function: <h3>AllocatePreviousMethodMemory</h3><br />Allocate a block of memory to store previous method information.<br />Delphi syntax: <br /><pre>function AllocatePreviousMethodMemory: Pointer; stdcall;</pre><br />C++ syntax: <br /><pre>virtual void * calltype AllocatePreviousMethodMemory() = 0;</pre><br /><br /><b>Params</b><dl><dt> This function has no parameters. </dt></dl><b>Return value</b><dl><dt>Return the memory pointer.</dt></dl><b>Remarks</b><dl><dt>You can pass the return value to IDirectCodeHook.Hook and IDirectCodeHook.Unhook.</dt></dl></div>

<a id="FreePreviousMethodMemory"></a><div class="function">Function: <h3>FreePreviousMethodMemory</h3><br />Free the memory block.<br />Delphi syntax: <br /><pre>procedure FreePreviousMethodMemory(APreviousMethod: Pointer); stdcall;</pre><br />C++ syntax: <br /><pre>virtual void FreePreviousMethodMemory(Pointer OldFunc) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">APreviousMethod</dt><dd>Pointer that returned by IDirectCodeHook.AllocatePreviousMethodMemory</dd></dl><b>Return value</b><dl><dt>This function doesn't return value. </dt></dl></div>


		 </div>
	</div>
</div>
<div class="footer">Copyright &copy; 2008, Wang Qi, All Rights Reserved.
</div>
</body>
</html>
