<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="author" content="ATopSoft" />
<meta name="copyright" content="Copyright &copy; 2004-2007, ATopSoft, All Rights Reserved." />
<meta name="rating" content="Safe For Kids" />
<meta name="keywords" lang="en" content="meta key" />
<meta name="description" content="meta desc" />

<title>Win32 CodeHook</title>
<style type="text/css">@import url('page.css');</style>
<link rel="stylesheet" type="text/css" href="page.css" />
</head>


<body>
<div class="header">
</div>
<div class="container">
	<div class="mainbox">
		 <div class="nav"><ul>
<li><a href="index.html">Introduction</a></li>
<li><a href="start.html">Get start</a></li>
<li><a href="api-icodehook.html">Interface - ICodeHook</a></li>
<li><a href="api-icodehookhelper.html">Interface - ICodeHookHelper</a></li>
<li><a href="api-idirectcodehook.html">Interface - IDirectCodeHook</a></li>
<li><a href="api-ierrorcodehook.html">Interface - IErrorCodeHook</a></li>
<li><a href="compare-raw-advanced-mode.html">Comparison of raw mode and advanced mode</a></li>
<li><a href="tutorial.html">Tutorials</a></li>
<li><a href="faq.html">FAQ</a></li>
<li><a href="support.html">Support</a></li>
<li><a href="version.html">Credits and Versions</a></li>

</ul>

		 </div>
		 <div class="content">Document of interface ICodeHook<br /><br />This is the root and kernel interface of Win32 CodeHook.<br />
You can call GetCodeHook to get the root interface.<br />
You can also call ICodeHook.CreateCodeHook to create a new interface.<br />
It supports both raw mode hook and advanced hook.<br /><br />Delphi syntax: <br /><pre>ICodeHook = interface(IErrorCodeHook)
	procedure <a href="#GetDirectCodeHook">GetDirectCodeHook</a>(out Obj); stdcall;
	procedure <a href="#GetCodeHookHelper">GetCodeHookHelper</a>(out Obj); stdcall;
	procedure <a href="#CreateCodeHook">CreateCodeHook</a>(out Obj); stdcall;
	procedure <a href="#SetUserDataSize">SetUserDataSize</a>(ASize: Integer); stdcall;
	function <a href="#Hook">Hook</a>(ATarget, AHook: Pointer): TCodeHookHandle; stdcall;
	function <a href="#Unhook">Unhook</a>(AHandle: TCodeHookHandle): LongBool; stdcall;
	function <a href="#GetHookInfo">GetHookInfo</a>(AHandle: TCodeHookHandle; AInfo: PCodeHookInfo): LongBool; stdcall;
	function <a href="#GetUserData">GetUserData</a>(AHandle: TCodeHookHandle): Pointer; stdcall;
	function <a href="#AdvancedHook">AdvancedHook</a>(ATargetObject: Pointer;
		ATarget: Pointer; ATargetCallingConvention: Integer;
		AHook: Pointer; AHookCallingConvention: Integer;
		AParamCount: Integer;
		AExtraParams: PCardinal; AExtraParamCount: Integer;
		AFlags: Cardinal): TCodeHookHandle; stdcall;
	function <a href="#AdvancedUnhook">AdvancedUnhook</a>(AHandle: TCodeHookHandle): LongBool; stdcall;
	function <a href="#FindHookHandleFromTarget">FindHookHandleFromTarget</a>(ATarget: Pointer): TCodeHookHandle; stdcall;
	function <a href="#CallPreviousMethod">CallPreviousMethod</a>(AHandle: TCodeHookHandle; AParams: PCardinal): Cardinal; stdcall;
	function <a href="#CallMethod">CallMethod</a>(AObject: Pointer; AMethod: Pointer;
		AParams: PCardinal; AParamCount: Integer; ACallingConvention: Integer): Cardinal; stdcall;
end;
</pre>C++ syntax: <br /><pre>class ICodeHook: public ICodeHookError {
public:
	virtual void _stdcall <a href="#GetDirectCodeHook">GetDirectCodeHook</a>(IDirectCodeHook **) = 0;
	virtual void _stdcall <a href="#GetCodeHookHelper">GetCodeHookHelper</a>(ICodeHookHelper **) = 0;
	virtual void _stdcall <a href="#CreateCodeHook">CreateCodeHook</a>(ICodeHook **) = 0;
	virtual void _stdcall <a href="#SetUserDataSize">SetUserDataSize</a>(int Size) = 0;
	virtual TCodeHookHandle _stdcall <a href="#Hook">Hook</a>(Pointer Target, Pointer <a href="#Hook">Hook</a>) = 0;
	virtual BOOL _stdcall <a href="#Unhook">Unhook</a>(TCodeHookHandle Handle) = 0;
	virtual BOOL _stdcall <a href="#GetHookInfo">GetHookInfo</a>(TCodeHookHandle Handle, PCodeHookInfo Info) = 0;
	virtual Pointer _stdcall <a href="#GetUserData">GetUserData</a>(TCodeHookHandle Handle) = 0;
	virtual TCodeHookHandle _stdcall <a href="#AdvancedHook">AdvancedHook</a>(Pointer TargetObject,
		Pointer Target, int TargetCallingConvention,
		Pointer <a href="#Hook">Hook</a>, int HookCallingConvention,
		int ParamCount,
		PUINT ExtraParams, int ExtraParamCount,
		UINT Flags) = 0;
	virtual BOOL _stdcall <a href="#AdvancedUnhook">AdvancedUnhook</a>(TCodeHookHandle Handle) = 0;
	virtual TCodeHookHandle _stdcall <a href="#FindHookHandleFromTarget">FindHookHandleFromTarget</a>(Pointer Target) = 0;
	virtual UINT _stdcall <a href="#CallPreviousMethod">CallPreviousMethod</a>(TCodeHookHandle Handle, PUINT Params) = 0;
	virtual UINT _stdcall <a href="#CallMethod">CallMethod</a>(Pointer Object, Pointer Method,
		PUINT Params, int ParamCount, int CallingConvention) = 0;
};
</pre><a id="GetDirectCodeHook"></a><div class="function">Function: <h3>GetDirectCodeHook</h3><br />Retrieve interface IDirectCodeHook<br />Delphi syntax: <br /><pre>procedure GetDirectCodeHook(out Obj); stdcall;</pre><br />C++ syntax: <br /><pre>virtual void calltype GetDirectCodeHook(IDirectCodeHook **) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">Obj</dt><dd>Address of pointer variable that receives the interface pointer.</dd></dl><b>Return value</b><dl><dt>This function doesn't return value. </dt></dl></div>

<a id="GetCodeHookHelper"></a><div class="function">Function: <h3>GetCodeHookHelper</h3><br />Retrieve interface ICodeHookHelper<br />Delphi syntax: <br /><pre>procedure GetCodeHookHelper(out Obj); stdcall;</pre><br />C++ syntax: <br /><pre>virtual void calltype GetCodeHookHelper(ICodeHookHelper **) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">Obj</dt><dd>Address of pointer variable that receives the interface pointer.</dd></dl><b>Return value</b><dl><dt>This function doesn't return value. </dt></dl></div>

<a id="CreateCodeHook"></a><div class="function">Function: <h3>CreateCodeHook</h3><br />Create an instance of interface ICodeHook<br />Delphi syntax: <br /><pre>procedure CreateCodeHook(out Obj); stdcall;</pre><br />C++ syntax: <br /><pre>virtual void calltype CreateCodeHook(ICodeHook **) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">Obj</dt><dd>Address of pointer variable that receives the interface pointer.</dd></dl><b>Return value</b><dl><dt>This function doesn't return value. </dt></dl><b>Remarks</b><dl><dt>Usually you don't need to call this function because the interface returned by GetCodeHook is enough to you.</dt></dl></div>

<a id="SetUserDataSize"></a><div class="function">Function: <h3>SetUserDataSize</h3><br />Set the user data record size.<br />Delphi syntax: <br /><pre>procedure SetUserDataSize(ASize: Integer); stdcall;</pre><br />C++ syntax: <br /><pre>virtual void calltype SetUserDataSize(int Size) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ASize</dt><dd>The size of user data in byte.</dd></dl><b>Return value</b><dl><dt>This function doesn't return value. </dt></dl><b>Remarks</b><dl><dt>You can specify a user data size and call GetUserData to retrieve the user data pointer then you can store information to the user data.</dt></dl></div>

<a id="Hook"></a><div class="function">Function: <h3>Hook</h3><br />Low level hook a method.<br />Delphi syntax: <br /><pre>function Hook(ATarget, AHook: Pointer): TCodeHookHandle; stdcall;</pre><br />C++ syntax: <br /><pre>virtual TCodeHookHandle calltype Hook(Pointer Target, Pointer Hook) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ATarget</dt><dd>Address of the target function.</dd><dt class="ParamName">AHook</dt><dd>Address of the hook function.</dd></dl><b>Return value</b><dl><dt>A handle that represents the code hook information.</dt></dl><b>Remarks</b><dl><dt>The prototype of the hook function should be exactly same as the target.<br />
That's to say, the parameters count and the calling convention should be same.</dt></dl></div>

<a id="Unhook"></a><div class="function">Function: <h3>Unhook</h3><br />Low level unhook a method.<br />Delphi syntax: <br /><pre>function Unhook(AHandle: TCodeHookHandle): LongBool; stdcall;</pre><br />C++ syntax: <br /><pre>virtual BOOL calltype Unhook(TCodeHookHandle Handle) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AHandle</dt><dd>The handle returned by HookMethod.</dd></dl><b>Return value</b><dl><dt>Return TRUE on success, otherwise, return FALSE.</dt></dl></div>

<a id="GetHookInfo"></a><div class="function">Function: <h3>GetHookInfo</h3><br />Retrieve the hook information.<br />Delphi syntax: <br /><pre>function GetHookInfo(AHandle: TCodeHookHandle; AInfo: PCodeHookInfo): LongBool; stdcall;</pre><br />C++ syntax: <br /><pre>virtual BOOL calltype GetHookInfo(TCodeHookHandle Handle, PCodeHookInfo Info) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AHandle</dt><dd>The handle represents the code hook information</dd><dt class="ParamName">AInfo</dt><dd>Pointer to a TCodeHookInfo record (structure).</dd></dl><b>Return value</b><dl><dt>Return TRUE on success, otherwise, return FALSE.</dt></dl></div>

<a id="GetUserData"></a><div class="function">Function: <h3>GetUserData</h3><br />Retrieve the user data buffer.<br />Delphi syntax: <br /><pre>function GetUserData(AHandle: TCodeHookHandle): Pointer; stdcall;</pre><br />C++ syntax: <br /><pre>virtual Pointer calltype GetUserData(TCodeHookHandle Handle) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AHandle</dt><dd>The handle represents the code hook information</dd></dl><b>Return value</b><dl><dt>If the function successes, returns the pointer to the user data. <br /> If the function fails, returns NULL (nil).</dt></dl><b>Remarks</b><dl><dt>User data is another way to store customized information beside extra parameters.<br />
User data allow you to store and retrieve any data in the code hook handle.<br />
The initial user data memory is guaranteed to be zero.<br />
<br />
Note:<br />
Don't forget to call ICodeHook.SetUserDataSize to set the property user data size, otherwise, you will get wrong user data memory.</dt></dl></div>

<a id="AdvancedHook"></a><div class="function">Function: <h3>AdvancedHook</h3><br />Advanced mode hook a method.<br />Delphi syntax: <br /><pre>function AdvancedHook(ATargetObject: Pointer;
      ATarget: Pointer; ATargetCallingConvention: Integer;
      AHook: Pointer; AHookCallingConvention: Integer;
      AParamCount: Integer;
      AExtraParams: PCardinal; AExtraParamCount: Integer;
      AFlags: Cardinal): TCodeHookHandle; stdcall;
</pre><br />C++ syntax: <br /><pre>virtual TCodeHookHandle calltype AdvancedHook(Pointer TargetObject,
		Pointer Target, int TargetCallingConvention,
		Pointer Hook, int HookCallingConvention,
		int ParamCount,
		PUINT ExtraParams, int ExtraParamCount,
		UINT Flags) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ATargetObject</dt><dd>Address of the "this" pointer of the target.<br />
If the target is a global function, set this parameter to NULL.</dd><dt class="ParamName">ATarget</dt><dd>Address of the target function.</dd><dt class="ParamName">ATargetCallingConvention</dt><dd>The calling convention of the target function.</dd><dt class="ParamName">AHook</dt><dd>Address of the hook function. See remarks.</dd><dt class="ParamName">AHookCallingConvention</dt><dd>The calling convention of the hook function.</dd><dt class="ParamName">AParamCount</dt><dd>The param count of the target function. See remarks.</dd><dt class="ParamName">AExtraParams</dt><dd>Pointer to extra parameters. See remarks.</dd><dt class="ParamName">AExtraParamCount</dt><dd>The count of extra parameters.</dd><dt class="ParamName">AFlags</dt><dd>For future use. Now pass it with 0.</dd></dl><b>Return value</b><dl><dt>A handle that represents the code hook information.</dt></dl><b>Remarks</b><dl><dt><b>Note on the hook function: </b><br />
The prototype of the hook function should be in a fixed form, independent on the target.<br />
The prototype should be,<br />
Delphi syntax: <b>function HookCallback(AExtraParam1: Cardinal; AExtraParam2: Cardinal .. AExtraParamN: Cardinal; AHandle: TCodeHookHandle; AParams: PCodeHookParamAccessor): Cardinal; CallingConvertion;</b><br />
C++ syntax: <b>DWORD CallingConvertion HookCallback(DWORD AExtraParam1, DWORD AExtraParam2 .. DWORD AExtraParamN, TCodeHookHandle AHandle, PDWORD AParams);</b><br />
If no extra parameters, the prototype should be<br />
Delphi syntax: <b>function HookCallback(AHandle: TCodeHookHandle; AParams: PCodeHookParamAccessor): Cardinal; CallingConvertion;</b><br />
C++ syntax: <b>DWORD CallingConvertion HookCallback(TCodeHookHandle AHandle, PDWORD AParams);</b><br />
<br />
You can access the hook information using AHandle by calling ICodeHook.GetHookInfo.<br />
You can also access the customized user data information using AHandle by calling ICodeHook.GetUserData.<br />
<br />
The parameter AParams is the parameters that are passed to the target function. You can access the parameters by accessing AParams[0], AParams[1], etc. For example, if the hook is for Windows API MessageBox, then AParams[0] is the first parameter of MessageBox, hWnd. AParams[1] is the second, lpText, AParams[2] is lpCaption, and AParams[3] is uType.<br />
<br />
This function assumes the hook function is a global function. If object function is used as hook, you should better use ICodeHookHelper.HookWithObjectMethod to make the hook.<br />
<br />
<b>Note on the parameter count: </b><br />
AParamCount is base on the presupposition that the target function takes simple parameters.<br />
"Simple" means all parameters are simple data type with no more than 32 bits. The simple data types include byte, char, short, word, int, dword, pointer, single float, etc.<br />
Other types such as double float (64 bits float), Intel extended float (80 bits float), Windows Variant type, record (structure) are not simple.<br />
<br />
If non-simple parameters are in the target function, you should better use raw mode hook and make the hook function exactly same prototype with the target function rather than using the advanced hook.<br />
<br />
<b>Note on the extra parameters: </b><br />
You can pass predefined values as extra parameters and fetch the values in the hook function. This is a good place to connect the hook function with current running enviroment. You can pass the necessary information to the hook function as parameters instead of putting it in the global context. A typical very useful use is to pass the "this" pointer if the hook is a class member function.<br />
The extra parameters are passed as partial of the hook function's parameters, beside the code hook handle (AHandle) and the parameter pointer (AParams).<br />
<br />
The order passing the mixed parameters is that the first extra parameter is passed, then the second, then the third, after all extra parameters are passed, the code hook handle (AHandle) is passed, and the parameter pointer (AParams) is passed last.<br />
So in both Delphi and C++, when declaring the hook function, the first extra parameter should be at the most left, and the parameter pointer (AParams) should be at the most right.</dt></dl></div>

<a id="AdvancedUnhook"></a><div class="function">Function: <h3>AdvancedUnhook</h3><br />Advanced mode unhook a method.<br />Delphi syntax: <br /><pre>function AdvancedUnhook(AHandle: TCodeHookHandle): LongBool; stdcall;</pre><br />C++ syntax: <br /><pre>virtual BOOL calltype AdvancedUnhook(TCodeHookHandle Handle) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AHandle</dt><dd>The handle returned by AdvancedHook.</dd></dl><b>Return value</b><dl><dt>Return TRUE on success, otherwise, return FALSE.</dt></dl></div>

<a id="FindHookHandleFromTarget"></a><div class="function">Function: <h3>FindHookHandleFromTarget</h3><br />Find handle from a given target address.<br />Delphi syntax: <br /><pre>function FindHookHandleFromTarget(ATarget: Pointer): TCodeHookHandle; stdcall;</pre><br />C++ syntax: <br /><pre>virtual TCodeHookHandle calltype FindHookHandleFromTarget(Pointer Target) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">ATarget</dt><dd>The target address to find.</dd></dl><b>Return value</b><dl><dt>If this function successes, return the handle found. Otherwise, return INVALID_CODEHOOK_HANDLE.</dt></dl><b>Remarks</b><dl><dt>To get the target address from a handle, use ICodeHook.GetHookInfo.</dt></dl></div>

<a id="CallPreviousMethod"></a><div class="function">Function: <h3>CallPreviousMethod</h3><br />Call previous function.<br />Delphi syntax: <br /><pre>function CallPreviousMethod(AHandle: TCodeHookHandle; AParams: PCardinal): Cardinal; stdcall;</pre><br />C++ syntax: <br /><pre>virtual UINT calltype CallPreviousMethod(TCodeHookHandle Handle, PUINT Params) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AHandle</dt><dd>The handle that represents the code hook information.</dd><dt class="ParamName">AParams</dt><dd>The pointer to the parameters.</dd></dl><b>Return value</b><dl><dt>Return what the previous function returns. If the previous function doesn't return a value, the return value is undefined.</dt></dl></div>

<a id="CallMethod"></a><div class="function">Function: <h3>CallMethod</h3><br />Call a function with specified calling convention and parameters.<br />Delphi syntax: <br /><pre>function CallMethod(AObject: Pointer; AMethod: Pointer;
      AParams: PCardinal; AParamCount: Integer; ACallingConvention: Integer): Cardinal; stdcall;
</pre><br />C++ syntax: <br /><pre>virtual UINT calltype CallMethod(Pointer Object, Pointer Method,
		PUINT Params, int ParamCount, int CallingConvention) = 0;</pre><br /><br /><b>Params</b><dl><dt class="ParamName">AObject</dt><dd>The object instance if the destination is an object method. If the destination is a global method, set this parameter to NULL.</dd><dt class="ParamName">AMethod</dt><dd>The address of the destination method.</dd><dt class="ParamName">AParams</dt><dd>The pointer to the parameters.</dd><dt class="ParamName">AParamCount</dt><dd>The parameters count.</dd><dt class="ParamName">ACallingConvention</dt><dd>The calling convention of the previous function.</dd></dl><b>Return value</b><dl><dt>Return what the function returns. If the function doesn't return a value, the return value is undefined.</dt></dl><b>Remarks</b><dl><dt>Usually use CallPreviousMethod instead of this function.<br />
This function should only be used when you use raw mode hooking while you want to call the previous function without prototype.</dt></dl></div>


		 </div>
	</div>
</div>
<div class="footer">Copyright &copy; 2008, Wang Qi, All Rights Reserved.
</div>
</body>
</html>
