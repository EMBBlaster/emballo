<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="author" content="ATopSoft" />
<meta name="copyright" content="Copyright &copy; 2004-2007, ATopSoft, All Rights Reserved." />
<meta name="rating" content="Safe For Kids" />
<meta name="keywords" lang="en" content="meta key" />
<meta name="description" content="meta desc" />

<title>Win32 CodeHook</title>
<style type="text/css">@import url('page.css');</style>
<link rel="stylesheet" type="text/css" href="page.css" />
</head>


<body>
<div class="header">
</div>
<div class="container">
	<div class="mainbox">
		 <div class="nav"><ul>
<li><a href="index.html">Introduction</a></li>
<li><a href="start.html">Get start</a></li>
<li><a href="api-icodehook.html">Interface - ICodeHook</a></li>
<li><a href="api-icodehookhelper.html">Interface - ICodeHookHelper</a></li>
<li><a href="api-idirectcodehook.html">Interface - IDirectCodeHook</a></li>
<li><a href="api-ierrorcodehook.html">Interface - IErrorCodeHook</a></li>
<li><a href="compare-raw-advanced-mode.html">Comparison of raw mode and advanced mode</a></li>
<li><a href="tutorial.html">Tutorials</a></li>
<li><a href="faq.html">FAQ</a></li>
<li><a href="support.html">Support</a></li>
<li><a href="version.html">Credits and Versions</a></li>

</ul>

		 </div>
		 <div class="content"><div class="RawVSAdvanced">
<table border="1">
<thead>
<tr>
	<th style="width:16%">Feature</td>
	<th style="width:32%">Raw mode hooking </td>
	<th>Advanced mode hooking </td>
</tr>
</thead>
<tr><td>Interfaces to use</td><td>1, ICodeHook<br />
2, IDirectCodeHook</td><td>1, ICodeHook<br />
2, ICodeHookHelper</td></tr>
<tr><td>Functions to use</td><td>1, For hooking, use ICodeHook.Hook, for unhooking, use ICodeHook.Unhook.<br />
2, For hooking, use IDirectCodeHook.Hook, for unhooking, use IDirectCodeHook.Unhook.</td><td>1, For hooking, use ICodeHook.Hook, for unhooking, use ICodeHook.Unhook.<br />
2, For hooking, use the functions which name starts with 'HookWith' in ICodeHookHelper, for unhooking, use ICodeHookHelper.UnhookTarget, ICodeHookHelper.UnhookAll, or ICodeHook.Unhook.</td></tr>
<tr><td>Limitation of the target function calling convention</td><td>None. Any calling convention function can be hooked.</td><td>Only certain calling convention functions are supported.<br />
The supported calling conventions are: stdcall (Windows API default), cdcel (C and C++ default), and register call (Delphi default).</td></tr>
<tr><td>Limitation of the target function parameters</td><td>None. Any parameters can be passed in any order.</td><td>The target function parameters should be simple. That means all parameters should be no bigger that 32 bits.<br />
The simple data types include byte, char, short, word, int, dword, pointer, single float, etc.<br />
Other types such as double float (64 bits float), Intel extended float (80 bits float), Windows Variant type, record (structure) are not simple.<br />
Each simple parameter is countable and can be added to the AParamCount of the hook function such as ICodeHook.AdvancedHook.<br />
If any parameter is not simple, you should better use the raw mode hooking unless you know deeply how compiler and assembly code works.</td></tr>
<tr><td>Limitation of the hook function</td><td>The prototype of the hook function should be exactly same as the target function, otherwise, you may get crash.</td><td>The prototype of the hook function is fixed, independent of the target function.<br />
<br />
The prototype is,<br />
Delphi syntax: function HookCallback(AExtraParam1: Cardinal; AExtraParam2: Cardinal .. AExtraParamN: Cardinal; AHandle: TCodeHookHandle; AParams: PCardinal): Cardinal; CallingConvertion;<br />
C++ syntax: DWORD CallingConvertion HookCallback(DWORD AExtraParam1, DWORD AExtraParam2 .. DWORD AExtraParamN, TCodeHookHandle AHandle, PDWORD AParams);<br />
<br />
If no extra parameters, the prototype is,<br />
Delphi syntax: function HookCallback(AHandle: TCodeHookHandle; AParams: PCardinal): Cardinal; CallingConvertion;<br />
C++ syntax: DWORD CallingConvertion HookCallback(TCodeHookHandle AHandle, PDWORD AParams);</td></tr>
<tr><td>Easy to call the old/previous function</td><td>No.<br />
All depend on yourself.<br />
You need to pass correct number of parameters, and pass all parameters in the correct registers or in the correct order to the stack.</td><td>Yes. It can't be easier!<br />
You only need to use ICodeHook.CallPreviousMethod to call old method without knowing detailed information of the target.<br />
The parameters taken by CallPreviousMethod is already passed to your hook function.</td></tr>
<tr><td>Can use one hook for multiple targets</td><td>No. Almost impossible. Raw mode hooking takes very few knowledge on the target functions.</td><td>Yes. Enough information is tracked by the advanced mode hooking, such as parameter count, target calling convention, etc.<br />
In fact after the new Denomo (with GDI resource leak detection) is released, you can see how I use one hook to monitor many target functions.</td></tr>
<tr><td>Can use object (class member) function as hook function</td><td>No. There is no way to pass the object itself ("Self" pointer for Delphi, "this" pointer for C++).</td><td>Yes. You can pass the object as an extra parameter. And ICodeHookHelper is more easier for use object function as hook.</td></tr>
<tr><td>Performance</td><td>Very high.<br />
Your hook function is connected to the target directly and the binary code flow is directly to your hook function with a jmp function.</td><td>A little lower, comparing with Raw mode hooking.<br />
Your hook function is connected to the target with a piece of bridge code. And the bridge code may cost some extra time to execute.<br />
However, unless you are making time critical hooking, the lower performance caused by the bridge code is much trivial and you can always ignore it.<br />
Win32 CodeHook can generate very compact code that cause very little CPU time.</td></tr>
</table>
</div>

		 </div>
	</div>
</div>
<div class="footer">Copyright &copy; 2008, Wang Qi, All Rights Reserved.
</div>
</body>
</html>
